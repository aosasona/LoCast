import { PGlite } from "@electric-sql/pglite";

type Migration = {
	up: string;
	down: string;
};

const MIGRATIONS: Record<string, Migration> = {
	"00001": {
		up: ``,
		down: "",
	},
};

export default class Migrator {
	private static MIGRATIONS_TABLE = "migrations";

	constructor(private db: PGlite) {}

	private async createMigrationsTable() {
		await this.db.query(`CREATE TABLE IF NOT EXISTS ${Migrator.MIGRATIONS_TABLE} (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      name TEXT NOT NULL,
      created_at TIMESTAMPTZ DEFAULT NOW()
    );`);
	}

	async migrate(): Promise<{ msg: string } | { error: Error }> {
		try {
			await this.createMigrationsTable();
			const lastMigration = await this.db.sql<{
				name: string;
			}>`SELECT name FROM ${Migrator.MIGRATIONS_TABLE} ORDER BY id, created_at DESC LIMIT 1;`;

			const lastMigrationName = lastMigration.rows[0]?.name;

			const migrationNames = Object.keys(MIGRATIONS);
			const lastMigrationIndex = migrationNames.indexOf(lastMigrationName);

			if (lastMigrationIndex === migrationNames.length - 1) {
				return { msg: "Already up to date" };
			}

			const migrationsToRun = migrationNames.slice(lastMigrationIndex + 1);

			for (const migrationName of migrationsToRun) {
				const migration = MIGRATIONS[migrationName];
				await this.db.transaction(async (db) => {
					await db.query(migration.up);
					await db.query(
						`INSERT INTO ${Migrator.MIGRATIONS_TABLE} (name) VALUES ($1);`,
						[migrationName],
					);
				});
			}

			return { msg: "Migration complete" };
		} catch (error) {
			return { error: error as Error };
		}
	}
}
